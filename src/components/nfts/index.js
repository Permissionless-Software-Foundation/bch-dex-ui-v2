/*
  Shows NFTs for sale on the DEX.
*/

// Global npm libraries
import React from 'react'
import { Container, Row, Card, Col, Button, Spinner } from 'react-bootstrap'
import axios from 'axios'
import Jdenticon from '@chris.troutner/react-jdenticon'

// Local libraries
import config from '../../config'
import TokenCard from './token-card'

// Global variables and constants
const SERVER = `${config.server}/`

class NFTs extends React.Component {
  constructor (props) {
    super(props)

    this.state = {
      appData: props.appData,
      offers: [],
      iconsAreLoaded: false,
      reloadInterval: null
    }
  }

  // Executes when the component mounts.
  async componentDidMount () {
    // Retrieve initial offer data
    await this.handleOffers()

    await this.lazyLoadTokenIcons()

    const oldInterval = this.state.reloadInterval
    clearInterval(oldInterval)

    // Get data and update the table periodically.
    const reloadInterval = setInterval(async () => {
      await this.handleOffers()
    }, 30000)

    this.setState({ reloadInterval })
  }

  render () {
    const tokenCards = this.generateCards()

    return (
      <>
        <Container>
          <Row>
            <Col xs={6} />

            <Col xs={4} style={{ textAlign: 'right' }}>
              {
                this.state.iconsAreLoaded
                  ? null
                  : (<Button variant='secondary'>Loading Token Icons <Spinner animation='border' /></Button>)
              }

            </Col>

            <Col xs={2} style={{ textAlign: 'right' }} />
          </Row>
          <br />

          <Row>
            {tokenCards}
          </Row>
        </Container>
      </>
    )
  }

  async handleOffers () {
    try {
      const offers = await this.getNftOffers()
      console.log('offers: ', offers)

      this.setState({
        offers
      })
    } catch (err) {
      console.error('Error in handleOffers: ', err)
      // Do NOT throw errors
    }
  }

  // REST request to get Offer data from bch-dex
  async getNftOffers () {
    try {
      const options = {
        method: 'GET',
        url: `${SERVER}offer/list/`,
        data: {}
      }
      const result = await axios.request(options)
      // console.log('result.data: ', result.data)

      const rawOffers = result.data

      // Filter out just the NFTs and simple NFTs.
      const nftOffers = rawOffers.filter((x) => {
        const displayCategory = x.displayCategory
        const isNft = displayCategory === 'nft'
        const isSimpleNft = displayCategory === 'simple-nft'

        if (isNft || isSimpleNft) return true

        return false
      })
      // console.log(`nftOffers: ${JSON.stringify(nftOffers, null, 2)}`)

      const existingOffers = this.state.offers
      const combinedOffers = []

      // Loop through each array. Skip the ones that already exist in the
      // existingOffers array.
      for (let i = 0; i < nftOffers.length; i++) {
        const nftOffer = nftOffers[i]
        let currentOffer = nftOffer

        for (let j = 0; j < existingOffers.length; j++) {
          const existingOffer = existingOffers[j]

          if (nftOffer.tokenId === existingOffer.tokenId) {
            // console.log('Existing offer found. Replacing new data with old.')
            // console.log('existingOffer: ', existingOffer)
            // console.log('nftOffer: ', nftOffer)

            // Replace the server data with the existing data.
            currentOffer = existingOffer
            break
          }
        }
        combinedOffers.push(currentOffer)

        // Add an tempory icon if this is a new Offer.
        if (!currentOffer.iconDownloaded) {
          console.log(`token ${currentOffer.tokenId} needs icon download 2`)
          currentOffer.icon = (<Jdenticon size='100' value={currentOffer.tokenId} />)
          currentOffer.iconDownloaded = false
        }
      }

      return combinedOffers
    } catch (err) {
      console.warn('Error in getOffers() ', err)
    }
  }

  // This function generates a Token Card for each token in the wallet.
  generateCards () {
    // console.log('generateCards() offerData: ', offerData)

    const tokens = this.state.offers

    const tokenCards = []

    for (let i = 0; i < tokens.length; i++) {
      const thisToken = tokens[i]
      // console.log(`thisToken: ${JSON.stringify(thisToken, null, 2)}`)

      const thisTokenCard = (
        <TokenCard
          appData={this.state.appData}
          token={thisToken}
          key={`${thisToken.tokenId}`}
        />
      )
      tokenCards.push(thisTokenCard)
    }

    return tokenCards
  }

  // This function is called by the componentDidMount() lifecycle function.
  // It replaces the autogenerated token icons with proper icons, downloaded
  // from the internet.
  async lazyLoadTokenIcons () {
    const tokens = this.state.offers
    // console.log(`lazy loading these tokens: ${JSON.stringify(tokens, null, 2)}`)

    const wallet = this.state.appData.bchWallet

    for (let i = 0; i < tokens.length; i++) {
      const thisToken = tokens[i]
      let tokenFound = false

      // console.log(`thisToken: ${JSON.stringify(thisToken, null, 2)}`)

      // Get the token data from psf-slp-indexer
      const tokenData = await wallet.getTokenData(thisToken.tokenId)
      // console.log(`tokenData: ${JSON.stringify(tokenData, null, 2)}`)

      if (!thisToken.iconDownloaded) {
        console.log(`token ${thisToken.tokenId} needs icon download`)
      }

      // If the URL property of the token has an IPFS CID, then it probably
      // follows the PS002 specification for tokens. Download the token icon
      // and replace the Jdenticon automatically-generated icon.
      // if (tokenData.mutableData.includes('ipfs://') && thisToken.iconNeedsDownload) {
      // const wallet = this.state.appData.bchWallet

      // Retrieve token data from psf-slp-indexer.
      // const tokenData = await wallet.getTokenData(thisToken.tokenId)
      // console.log(`tokenData: ${JSON.stringify(tokenData, null, 2)}`)

      // If the token has mutable data, then try to retrieve it from IPFS.
      if (!thisToken.iconDownloaded && tokenData.mutableData && tokenData.mutableData.includes('ipfs://')) {
        const cid = tokenData.mutableData.substring(7)
        // console.log('cid')

        // Retrieve the mutable data from Filecoin/IPFS.
        const url = `https://${cid}.ipfs.dweb.link/data.json`
        const result = await axios.get(url)

        const mutableData = result.data
        // console.log(`mutableData: ${JSON.stringify(mutableData, null, 2)}`)

        const tokenIcon = mutableData.tokenIcon

        const newIcon = (
          <Card.Img src={tokenIcon} style={{ width: '100px' }} />
        )

        tokenFound = true

        // Add the JSX for the icon to the token object.
        thisToken.icon = newIcon
      }
      // }

      // If the token does not have mutable data to store icon data,
      // Check the slp-token-icon GitHub repository for an icon:
      // https://github.com/kosinusbch/slp-token-icons
      if (!tokenFound && !thisToken.iconDownloaded) {
        const url = `https://tokens.bch.sx/100/${thisToken.tokenId}.png`
        // console.log('url: ', url)

        // Check to see if icon exists. If it doesn't, axios will throw an error
        // and this function can exit.
        try {
          await axios.get(url)

          const newIcon = (
            <Card.Img src={url} style={{ width: '100px' }} />
          )

          // Add the JSX for the icon to the token object.
          thisToken.icon = newIcon
        } catch (err) {
          /* exit quietly */
        }
      }

      // Signal that a token download has been attempted.
      thisToken.iconDownloaded = true

      // Add the token data from the indexer
      thisToken.tokenData = tokenData
    }

    // Update the state of the wallet with the balances
    // this.state.appData.updateBchWalletState({ slpTokens: tokens })

    this.setState({
      iconsAreLoaded: true,
      tokens
    })
  }
}

export default NFTs
